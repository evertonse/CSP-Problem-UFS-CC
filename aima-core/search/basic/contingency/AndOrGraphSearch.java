package aima.core.search.basic.contingency;

import java.util.ArrayList;
import java.util.List;

import aima.core.search.api.ConditionalPlan;
import aima.core.search.api.NondeterministicProblem;
import aima.core.search.api.SearchForConditionalPlanFunction;
import aima.core.search.basic.support.BasicConditionalPlan;
import aima.core.util.datastructure.Pair;

/**
 * Artificial Intelligence A Modern Approach (4th Edition): Figure ??, page
 * ??.<br>
 * <br>
 * 
 * <pre>
 * <code>
 * function AND-OR-GRAPH-SEARCH(problem) returns a conditional plan, or failure
 *   OR-SEARCH(problem.INITIAL-STATE, problem, [])
 * 
 * ---------------------------------------------------------------------------------
 * 
 * function OR-SEARCH(state, problem, path) returns a conditional plan, or failure
 *   if problem.GOAL-TEST(state) then return the empty plan
 *   if state is on path then return failure
 *   for each action in problem.ACTIONS(state) do
 *       plan <- AND-SEARCH(RESULTS(state, action), problem, [state | path])
 *       if plan != failure then return [action | plan]
 *   return failure
 * 
 * ---------------------------------------------------------------------------------
 * 
 * function AND-SEARCH(states, problem, path) returns a conditional plan, or failure
 *   for each s<sub>i</sub> in states do
 *      plan<sub>i</sub> <- OR-SEARCH(s<sub>i</sub>, problem, path)
 *      if plan<sub>i</sub> = failure then return failure
 *   return [if s<sub>1</sub> then plan<sub>1</sub> else if s<sub>2</sub> then plan<sub>2</sub> else ... if s<sub>n-1</sub> then plan<sub>n-1</sub> else plan<sub>n</sub>]
 * </code>
 * </pre>
 * 
 * Figure ?? An algorithm for searching AND-OR graphs generated by
 * nondeterministic environments. It returns a conditional plan that reaches a
 * goal state in all circumstances. (The notation [x | l] refers to the list
 * formed by adding object x to the front of the list l.)<br>
 * <br>
 * 
 * @param <A>
 *            the type of the actions that can be performed.
 * @param <S>
 *            the type of the state space
 * 
 * @author Ciaran O'Reilly
 * @author Andrew Brown
 * @author Anurag Rai
 */
public class AndOrGraphSearch<A, S> implements SearchForConditionalPlanFunction<A, S> {

	// function AND-OR-GRAPH-SEARCH(problem) returns a conditional plan, or
	// failure
	@Override
	public ConditionalPlan<A, S> apply(NondeterministicProblem<A, S> problem) {
		// OR-SEARCH(problem.INITIAL-STATE, problem, [])
		return orSearch(problem.initialState(), problem, newPath());
	}

	// function OR-SEARCH(state, problem, path) returns a conditional plan, or
	// failure
	public ConditionalPlan<A, S> orSearch(S state, NondeterministicProblem<A, S> problem, List<S> path) {
		// if problem.GOAL-TEST(state) then return the empty plan
		if (problem.isGoalState(state)) {
			return emptyPlan();
		}
		// if state is on path then return failure
		if (path.contains(state)) {
			return failure();
		}
		List<S> statePlusPath = newPath(state, path);
		// for each action in problem.ACTIONS(state) do
		for (A action : problem.actions(state)) {
			// plan <- AND-SEARCH(RESULTS(state, action), problem, [state |
			// path])
			ConditionalPlan<A, S> plan = andSearch(problem.results(state, action), problem, statePlusPath);
			// if plan != failure then return [action | plan]
			if (plan != failure()) {
				return newPlan(action, plan);
			}
		}
		// return failure
		return failure();
	}

	// function AND-SEARCH(states, problem, path) returns a conditional plan, or
	// failure
	public ConditionalPlan<A, S> andSearch(List<S> states, NondeterministicProblem<A, S> problem, List<S> path) {		
		List<Pair<S, ConditionalPlan<A, S>>> conditionedPlans = new ArrayList<>();
		// for each s<sub>i</sub> in states do
		for (S s_i : states) {
			// plan<sub>i</sub> <- OR-SEARCH(s<sub>i</sub>, problem, path)
			ConditionalPlan<A, S> plan_i = orSearch(s_i, problem, path);
			// if plan<sub>i</sub> = failure then return failure
			if (plan_i == failure()) {
				return failure();
			}
			conditionedPlans.add(new Pair<>(s_i, plan_i));
		}
		// return [if s<sub>1</sub> then plan<sub>1</sub> else if s<sub>2</sub>
		// then plan<sub>2</sub> else ... if s<sub>n-1</sub> then
		// plan<sub>n-1</sub> else plan<sub>n</sub>]
		return newPlan(conditionedPlans);
	}

	//
	// Supporting Code
	public List<S> newPath() {
		return new ArrayList<>();
	}

	public List<S> newPath(S state, List<S> path) {
		List<S> newPath = newPath();
		newPath.add(state);
		newPath.addAll(path);
		return newPath;
	}

	public ConditionalPlan<A, S> emptyPlan() {
		return new BasicConditionalPlan<>();
	}

	public ConditionalPlan<A, S> failure() {
		return null;
	}

	public ConditionalPlan<A, S> newPlan(A action, ConditionalPlan<A, S> plan) {
		return new BasicConditionalPlan<>(action, plan);
	}

	public ConditionalPlan<A, S> newPlan(List<Pair<S, ConditionalPlan<A, S>>> conditionedPlans) {
		return new BasicConditionalPlan<>(conditionedPlans);
	}
}